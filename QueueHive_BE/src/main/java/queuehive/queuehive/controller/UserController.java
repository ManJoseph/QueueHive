package queuehive.queuehive.controller;

import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;
import queuehive.queuehive.dto.UpdateUserRequest;
import queuehive.queuehive.dto.UserDto;
import queuehive.queuehive.service.UserService;

@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    // Helper method to get authenticated user's ID
    private Long getAuthenticatedUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        // Assuming your User entity's ID is stored as the principal's name or a custom claim
        // This might need adjustment based on how Spring Security is configured to store user ID.
        // For JWT based authentication, the subject (email) is usually the principal name.
        // If you're storing the actual ID in the JWT, you'd need to parse the token here,
        // or a custom UserDetailsService would load a custom UserDetails object containing the ID.
        // For now, let's assume we can retrieve the email and use it to find the user.
        // A more robust solution for ID retrieval would involve a custom principal or token parsing.

        // Temporarily, we'll try to get the ID from local storage on the frontend and send it
        // Or, more securely, extract from JWT claims on the backend
        // For now, let's assume UserDetails has the ID (e.g., if User.id is the principal's name).
        // If not, we would need to fetch the User from DB using the principal's email/username.

        // A better approach for JWT-based auth:
        // Use a custom @AuthenticationPrincipal annotation or extract from JWT directly.
        // For simplicity and to proceed, let's assume `authentication.getName()` returns the user's email,
        // and we fetch the user to get their ID. This is not ideal as it hits DB for every call.
        // The JWT should ideally contain the user ID.

        // REVISION: The JWT (generated by JwtServiceImpl) now puts 'userId' as a claim.
        // We need a way to extract this claim. This typically happens via a JWT filter
        // that populates SecurityContextHolder with a custom Authentication object or principal.
        // For now, let's assume `authentication.getName()` is the user's email, and we fetch the user to get the ID.
        // This is a common pattern for initial setup, but can be optimized.
        
        String userEmail = authentication.getName(); // Get email from authenticated principal
        UserDto userDto = userService.findUserByEmail(userEmail)
                                     .orElseThrow(() -> new RuntimeException("Authenticated user not found"));
        return userDto.getId();
    }


    @GetMapping("/me")
    public ResponseEntity<UserDto> getCurrentUser() {
        // This assumes the user ID is passed from the frontend (e.g., in a header or JWT claim)
        // A more secure way would be to extract it directly from the authenticated principal.
        // For now, let's retrieve the user based on the authenticated principal's email.
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String userEmail = authentication.getName();
        UserDto currentUser = userService.findUserByEmail(userEmail)
                                        .orElseThrow(() -> new RuntimeException("Authenticated user not found."));
        return ResponseEntity.ok(currentUser);
    }

    @PutMapping("/update")
    public ResponseEntity<UserDto> updateUser(@Valid @RequestBody UpdateUserRequest request) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String userEmail = authentication.getName();
        UserDto existingUser = userService.findUserByEmail(userEmail)
                                           .orElseThrow(() -> new RuntimeException("Authenticated user not found."));

        UserDto updatedUser = userService.updateUser(existingUser.getId(), request);
        return ResponseEntity.ok(updatedUser);
    }
}
